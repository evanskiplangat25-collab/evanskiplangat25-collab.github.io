import { mergeProps, unref, computed, withAsyncContext, watch, useSSRContext } from 'file:///home/norman/Development/Techxtrasol/Vue/evanskiplangat25-collab.github.io/node_modules/vue/index.mjs';
import { ssrRenderComponent, ssrRenderSlot } from 'file:///home/norman/Development/Techxtrasol/Vue/evanskiplangat25-collab.github.io/node_modules/vue/server-renderer/index.mjs';
import { useForwardProps } from 'file:///home/norman/Development/Techxtrasol/Vue/evanskiplangat25-collab.github.io/node_modules/reka-ui/dist/index.js';
import { K as reactiveOmit, m as _sfc_main$o, E as useAsyncData } from './server.mjs';
import { M as MDCRenderer } from './MDCRenderer-D0liT7g8.mjs';

const _sfc_main$1 = /* @__PURE__ */ Object.assign({ inheritAttrs: false }, {
  __name: "UColorModeAvatar",
  __ssrInlineRender: true,
  props: {
    light: { type: String, required: true },
    dark: { type: String, required: true },
    as: { type: null, required: false },
    alt: { type: String, required: false },
    icon: { type: null, required: false },
    text: { type: String, required: false },
    size: { type: null, required: false },
    chip: { type: [Boolean, Object], required: false },
    class: { type: null, required: false },
    style: { type: null, required: false },
    ui: { type: null, required: false }
  },
  setup(__props) {
    const props = __props;
    const avatarProps = useForwardProps(reactiveOmit(props, "light", "dark"));
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<!--[-->`);
      _push(ssrRenderComponent(_sfc_main$o, mergeProps({ ...unref(avatarProps), ..._ctx.$attrs }, {
        src: __props.light,
        class: "dark:hidden"
      }), null, _parent));
      _push(ssrRenderComponent(_sfc_main$o, mergeProps({ ...unref(avatarProps), ..._ctx.$attrs }, {
        src: __props.dark,
        class: "hidden dark:block"
      }), null, _parent));
      _push(`<!--]-->`);
    };
  }
});
const _sfc_setup$1 = _sfc_main$1.setup;
_sfc_main$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/@nuxt/ui/dist/runtime/components/color-mode/ColorModeAvatar.vue");
  return _sfc_setup$1 ? _sfc_setup$1(props, ctx) : void 0;
};
const _sfc_main = {
  __name: "MDC",
  __ssrInlineRender: true,
  props: {
    tag: {
      type: [String, Boolean],
      default: "div"
    },
    /**
     * Raw markdown string or parsed markdown object from `parseMarkdown`
     */
    value: {
      type: [String, Object],
      required: true
    },
    /**
     * Render only the excerpt
     */
    excerpt: {
      type: Boolean,
      default: false
    },
    /**
     * Options for `parseMarkdown`
     */
    parserOptions: {
      type: Object,
      default: () => ({})
    },
    /**
     * Class to be applied to the root element
     */
    class: {
      type: [String, Array, Object],
      default: ""
    },
    /**
     * Tags to unwrap separated by spaces
     * Example: 'ul li'
     */
    unwrap: {
      type: [Boolean, String],
      default: false
    },
    /**
     * Async Data Unique Key
     * @default `hash(props.value)`
     */
    cacheKey: {
      type: String,
      default: void 0
    },
    /**
     * Partial parsing (if partial is `true`, title and toc generation will not be generated)
     */
    partial: {
      type: Boolean,
      default: true
    }
  },
  async setup(__props) {
    let __temp, __restore;
    const props = __props;
    const key = computed(() => props.cacheKey ?? hashString(props.value));
    const { data, refresh, error } = ([__temp, __restore] = withAsyncContext(async () => useAsyncData(key.value, async () => {
      if (typeof props.value !== "string") {
        return props.value;
      }
      const { parseMarkdown } = await import('./index-XVjGuPOT.mjs');
      return await parseMarkdown(props.value, {
        ...props.parserOptions,
        toc: props.partial ? false : props.parserOptions?.toc,
        contentHeading: props.partial ? false : props.parserOptions?.contentHeading
      });
    }, "$R23qlhow_i")), __temp = await __temp, __restore(), __temp);
    const body = computed(() => props.excerpt ? data.value?.excerpt : data.value?.body);
    watch(() => props.value, () => {
      refresh();
    });
    function hashString(str) {
      if (typeof str !== "string") {
        str = JSON.stringify(str || "");
      }
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 6) - hash + char;
        hash = hash & hash;
      }
      return `mdc-${hash === 0 ? "0000" : hash.toString(36)}-key`;
    }
    return (_ctx, _push, _parent, _attrs) => {
      const _component_MDCRenderer = MDCRenderer;
      ssrRenderSlot(_ctx.$slots, "default", {
        data: unref(data)?.data,
        body: unref(data)?.body,
        toc: unref(data)?.toc,
        excerpt: unref(data)?.excerpt,
        error: unref(error)
      }, () => {
        if (body.value) {
          _push(ssrRenderComponent(_component_MDCRenderer, {
            tag: props.tag,
            class: props.class,
            body: body.value,
            data: unref(data)?.data,
            unwrap: props.unwrap
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
      }, _push, _parent);
    };
  }
};
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/@nuxtjs/mdc/dist/runtime/components/MDC.vue");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};

export { _sfc_main$1 as _, _sfc_main as a };
//# sourceMappingURL=MDC-B7ZZbIm5.mjs.map
